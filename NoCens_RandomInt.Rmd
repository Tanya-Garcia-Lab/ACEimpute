---
title: "Estimating Equations: Only Random Intercept, No Censoring"
author: "Kyle Grosser"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
rm(list = ls())

library(impeRfect)
library(tidyverse)
library(lme4)
library(geex)
```

# Model 1

\begin{align*}
Y_{ij} &= \beta_0 + X_{ij}\beta + b_i + \epsilon_{ij} \\
\beta_0 &= 1.5 \\
\beta &= (2, -1) \\
b_i &\sim \textrm{N}(0,1) \\
\epsilon_{ij} &\sim \textrm{N}(0,\sigma^2)
\end{align*}

The first covariate ($X_1$) is generated from $Bern(0.5)$ and is time-invariant while the second covariate $X_2$ is generated from $N(0, 1)$ and is time-variant.

## Data Simulation

```{r Simulate.Data.1}
set.seed(95)
# number of clusters; obs. per cluster; total obs
n = 1000; m = 3; N = n*m
# number of fixed effects; fixed effects covariates
p = 3
# fixed effects
beta = c(1.5, 2, -1)
# random error sd; random errors
sigma = 1
epsilon = rnorm(N, 0, sigma)
# number of random effects
q = 1
Z = matrix(1, N)
if (q > 1) { Z = cbind(Z, X[, 1:(q - 1)]) }
# random effects
b = matrix(rnorm(n*q, 0, 1), n)
# b = rt(n = n, df = 10)
# response Y
sample.data = data.frame(id = rep(1:n, each = m), Y = beta[1] + rep(b, each = m) + epsilon)
if (p > 1) {
  sample.data = sample.data %>%
    mutate(X1 = rep(rbinom(n, 1, 0.5), each = m), Y = Y + beta[2] * X1)
}
if (p > 2) {
  sample.data = sample.data %>% 
    mutate(X2 = rnorm(N, 0, 1), Y = Y + beta[3] * X2)
}
# matrix M used for transforming Y 
M = rbind(matrix(1, 1, m), cbind(matrix(0, m - q, q), diag(m - q)))
# M^{-1}
M.inv = solve(M)
M.inv
head(sample.data, 10) %>% knitr::kable()
```

If the covariate X1 is time invariant, then the following cell should return exactly 3

```{r Time.Invariant.Check.1, message=F}
# check for time invariant
sample.data %>% group_by(id, X1) %>% summarise(n = n()) %>%
  .$n %>% mean()
```

## Parameter Estimation

```{r Estimate.Parameters.1, cache=F, echo=F}
# use lmer() to fit linear mixed effects model
lme.results = lmer(formula = Y ~ X1 + X2 + (1 | id), data = sample.data) %>%
  summary()
theta.lme = c(coef(lme.results)[,1], lme.results$sigma^2)

# use lmer estimates as initial theta estimates
theta.init = theta.lme
names(theta.init) = c(paste0("beta", 1:p - 1), "sigma2")

# use m_estimate() to solve estimating equations defined above
ee.results = m_estimate(estFUN = eff_score_vec, 
                        data = sample.data, units = "id",
                        root_control = setup_root_control(start = theta.init),
                        outer_args = list(response = "Y", variant.X = c("X1", "X2")))
theta.ee = coef(ee.results)

se.theta.lme = sqrt(diag(vcov(lme.results)))
se.theta.ee = sqrt(diag(vcov(ee.results))[1:p])
```

```{r Present.Results.1, echo=F}
# compare beta estimates
results.df <- matrix(c(beta, sigma^2, theta.ee, theta.lme), 3, p + 1, T) %>%
  as.data.frame() %>%
  cbind(c("Truth", "Estimating Equation", "lmer()"), .)
colnames(results.df) <- c("Method", 
                          paste0("$\\beta_", 1:p, "$"),
                          "$\\sigma^2$")
knitr::kable(results.df, caption = "Parameter Estimates")

se.df <- matrix(c(se.theta.ee, se.theta.lme), 2, p, T) %>%
  as.data.frame() %>%
  cbind(c("Estimating Equation", "lmer()"), .)
colnames(se.df) <- c("Method", paste0("$\\beta_", 1:p, "$"))

knitr::kable(se.df, caption = "SE Estimates")
```

NOW MODEL 2 DOESN'T CONVERGE. HMM. CONVERGENCE CRITERIA?

# Model 2

\begin{align*}
Y_{ij} &= \beta_0 + X_{ij}\beta + b_i + \epsilon_{ij} \\
\beta_0 &= 1.5 \\
\beta &= (2, -1) \\
b_i &\sim \textrm{N}(0,1) \\
\epsilon_{ij} &\sim \textrm{N}(0,\sigma^2)
\end{align*}

The two covariates ($X_1$ and $X_2$) are generated from $N(0, 1)$ and are time-variant.

## Data Simulation

```{r Simulate.Data.2}
set.seed(95)
# number of clusters; obs. per cluster; total obs
n = 1000; m = 3; N = n*m
# number of fixed effects; fixed effects covariates
p = 3
# fixed effects
beta = c(1.5, 2, -1)
# random error sd; random errors
sigma = 1
epsilon = rnorm(N, 0, sigma)
# number of random effects
q = 1
Z = matrix(1, N)
if (q > 1) { Z = cbind(Z, X[, 1:(q - 1)]) }
# random effects
b = matrix(rnorm(n*q, 0, 1), n)
# b = rt(n = n, df = 10)
# response Y
sample.data = data.frame(id = rep(1:n, each = m), Y = beta[1] + rep(b, each = m) + epsilon)
if (p > 1) {
  sample.data = sample.data %>% 
    mutate(X1 = rnorm(N, 0, 1), Y = Y + beta[2] * X1)
}
if (p > 2) {
  sample.data = sample.data %>% 
    mutate(X2 = rnorm(N, 0, 1), Y = Y + beta[3] * X2)
}
# matrix M used for transforming Y 
M = rbind(matrix(1, 1, m), cbind(matrix(0, m - q, q), diag(m - q)))
# M^{-1}
M.inv = solve(M)
head(sample.data, 10) %>% knitr::kable()
```

## Parameter Estimation

```{r Estimate.Parameters.2, cache=F, echo=F}
# use lmer() to fit linear mixed effects model
lme.results = lmer(formula = Y ~ X1 + X2 + (1 | id), data = sample.data) %>%
  summary()
theta.lme = c(coef(lme.results)[,1], lme.results$sigma^2)

# use lmer estimates as initial theta estimates
theta.init = theta.lme
names(theta.init) = c(paste0("beta", 1:p - 1), "sigma2")

# use m_estimate() to solve estimating equations defined above
ee.results = m_estimate(estFUN = eff_score_vec, 
                        data = sample.data, units = "id",
                        root_control = setup_root_control(start = theta.init),
                        outer_args = list(response = "Y", variant.X = c("X1", "X2")))
theta.ee = coef(ee.results)

se.theta.lme = sqrt(diag(vcov(lme.results)))
se.theta.ee = sqrt(diag(vcov(ee.results))[1:p])
```

```{r Present.Results.2, echo=F}
# compare beta estimates
results.df <- matrix(c(beta, sigma^2, theta.ee, theta.lme), 3, p + 1, T) %>%
  as.data.frame() %>%
  cbind(c("Truth", "Estimating Equation", "lmer()"), .)
colnames(results.df) <- c("Method", 
                          paste0("$\\beta_", 1:p, "$"),
                          "$\\sigma^2$")
knitr::kable(results.df, caption = "Parameter Estimates")

se.df <- matrix(c(se.theta.ee, se.theta.lme), 2, p, T) %>%
  as.data.frame() %>%
  cbind(c("Estimating Equation", "lmer()"), .)
colnames(se.df) <- c("Method", paste0("$\\beta_", 1:p, "$"))

knitr::kable(se.df, caption = "SE Estimates")
```

# Model 3

\begin{align*}
Y_{ij} &= \beta_0 + X_{ij}\beta + b_i + \epsilon_{ij} \\
\beta_0 &= 1.5 \\
\beta &= (2, -1, 0.5) \\
b_i &\sim \textrm{N}(0,1) \\
\epsilon_{ij} &\sim \textrm{N}(0,\sigma^2)
\end{align*}

The first covariate ($X_1$) is generated from $Bern(0.5)$ and is time-invariant while the second and third covariates ($X_2$ and $X_3$) are generated from $N(0, 1)$ and are time-variant.

## Data Simulation

```{r Simulate.Data.3}
set.seed(95)
# number of clusters; obs. per cluster; total obs
n = 1000; m = 3; N = n*m
# number of fixed effects; fixed effects covariates
p = 4
# fixed effects
beta = c(1.5, 2, -1, 0.5)
# random error sd; random errors
sigma = 1
epsilon = rnorm(N, 0, sigma)
# number of random effects
q = 1
Z = matrix(1, N)
if (q > 1) { Z = cbind(Z, X[, 1:(q - 1)]) }
# random effects
b = matrix(rnorm(n*q, 0, 1), n)
# b = rt(n = n, df = 10)
# response Y
sample.data = data.frame(id = rep(1:n, each = m), Y = beta[1] + rep(b, each = m) + epsilon)
if (p > 1) {
  sample.data = sample.data %>%
    mutate(X1 = rep(rbinom(n, 1, 0.5), each = m), Y = Y + beta[2] * X1)
}
if (p > 2) {
  sample.data = sample.data %>% 
    mutate(X2 = rnorm(N, 0, 1), Y = Y + beta[3] * X2)
}
if (p > 3) {
  sample.data = sample.data %>% 
    mutate(X3 = rnorm(N, 0, 1), Y = Y + beta[4] * X3)
}
head(sample.data, 10) %>% knitr::kable()
```

If the covariate X1 is time invariant, then the following cell should return exactly 3

```{r Time.Invariant.Check.3, message=F}
# check for time invariant
sample.data %>% group_by(id, X1) %>% summarise(n = n()) %>%
  .$n %>% mean()
```

## Parameter Estimation

```{r Estimate.Parameters.3, cache=F, echo=F}
# use lmer() to fit linear mixed effects model
lme.results = lmer(formula = Y ~ X1 + X2 + X3 + (1 | id), data = sample.data) %>%
  summary()
theta.lme = c(coef(lme.results)[,1], lme.results$sigma^2)

# use lmer estimates as initial theta estimates
theta.init = theta.lme
names(theta.init) = c(paste0("beta", 1:p - 1), "sigma2")

# use m_estimate() to solve estimating equations defined above
ee.results = m_estimate(estFUN = eff_score_vec, 
                        data = sample.data, units = "id",
                        root_control = setup_root_control(start = theta.init),
                        outer_args = list(response = "Y", variant.X = c("X1", "X2", "X3")))
theta.ee = coef(ee.results)

se.theta.lme = sqrt(diag(vcov(lme.results)))
se.theta.ee = sqrt(diag(vcov(ee.results))[1:p])
```

```{r Present.Results.3, echo=F}
# compare beta estimates
results.df <- matrix(c(beta, sigma^2, theta.ee, theta.lme), 3, p + 1, T) %>%
  as.data.frame() %>%
  cbind(c("Truth", "Estimating Equation", "lmer()"), .)
colnames(results.df) <- c("Method", 
                          paste0("$\\beta_", 1:p, "$"),
                          "$\\sigma^2$")
knitr::kable(results.df, caption = "Parameter Estimates")

se.df <- matrix(c(se.theta.ee, se.theta.lme), 2, p, T) %>%
  as.data.frame() %>%
  cbind(c("Estimating Equation", "lmer()"), .)
colnames(se.df) <- c("Method", paste0("$\\beta_", 1:p, "$"))

knitr::kable(se.df, caption = "SE Estimates")
```

Model 3 did not converge when I forgot to add the random intercept to the outcome??

# Model 4

\begin{align*}
Y_{ij} &= \beta_0 + X_{ij}\beta + b_i + \epsilon_{ij} \\
\beta_0 &= 1.5 \\
\beta &= (2, -1, 0.5, 1.2, -2) \\
b_i &\sim \textrm{N}(0,1) \\
\epsilon_{ij} &\sim \textrm{N}(0,\sigma^2)
\end{align*}

The 5 covariates ($X_1$ through $X_5$) are all generated from $N(0, 1)$ and are time-invariant.

## Data Simulation

```{r Simulate.Data.4}
set.seed(95)
# number of clusters; obs. per cluster; total obs
n = 1000; m = 3; N = n*m
# number of fixed effects; fixed effects covariates
p = 6
X = rnorm((p-1)*N, 0, 1) %>% matrix(N)
colnames(X) = paste0("X", 1:(p-1))
# colnames(X) = paste0("X", 1:(p-1))
# fixed effects
beta = c(1.5, 2, -1, 0.5, 1.2, -2)
# random error sd; random errors
sigma = 1
epsilon = rnorm(N, 0, sigma)
# number of random effects
q = 1
Z = matrix(1, N)
if (q > 1) { Z = cbind(Z, X[, 1:(q - 1)]) }
# random effects
b = matrix(rnorm(n*q, 0, 1), n)
# b = rt(n = n, df = 10)
# response Y
sample.data = data.frame(id = rep(1:n, each = m), Y = beta[1] + rep(b, each = m) + epsilon, X) %>%
  mutate(Y = Y + X %*% beta[2:p])
# matrix M used for transforming Y 
M = rbind(matrix(1, 1, m), cbind(matrix(0, m - q, q), diag(m - q)))
# M^{-1}
M.inv = solve(M)
head(sample.data, 10) %>% knitr::kable()
```

## Parameter Estimation

```{r Estimate.Parameters.4, cache=F, echo=F}
# use lmer() to fit linear mixed effects model
lme.results = lmer(formula = Y ~ X1 + X2 + X3 + X4 + X5 + (1 | id), data = sample.data) %>%
  summary()
theta.lme = c(coef(lme.results)[,1], lme.results$sigma^2)

# use lmer estimates as initial theta estimates
theta.init = theta.lme
names(theta.init) = c(paste0("beta", 1:p - 1), "sigma2")

# use m_estimate() to solve estimating equations defined above
ee.results = m_estimate(estFUN = eff_score_vec, 
                        data = sample.data, units = "id",
                        root_control = setup_root_control(start = theta.init),
                        outer_args = list(response = "Y", variant.X = paste0("X", 1:5)))
theta.ee = coef(ee.results)

se.theta.lme = sqrt(diag(vcov(lme.results)))
se.theta.ee = sqrt(diag(vcov(ee.results))[1:p])
```

```{r Present.Results.4, echo=F}
# compare beta estimates
results.df <- matrix(c(beta, sigma^2, theta.ee, theta.lme), 3, p + 1, T) %>%
  as.data.frame() %>%
  cbind(c("Truth", "Estimating Equation", "lmer()"), .)
colnames(results.df) <- c("Method", 
                          paste0("$\\beta_", 1:p, "$"),
                          "$\\sigma^2$")
knitr::kable(results.df, caption = "Parameter Estimates")

se.df <- matrix(c(se.theta.ee, se.theta.lme), 2, p, T) %>%
  as.data.frame() %>%
  cbind(c("Estimating Equation", "lmer()"), .)
colnames(se.df) <- c("Method", paste0("$\\beta_", 1:p, "$"))

knitr::kable(se.df, caption = "SE Estimates")
```