---
title: "Estimating Equations: Only Random Intercept, with Censoring"
author: "Kyle Grosser"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
rm(list = ls())

library(impeRfect)
library(tidyverse)
library(lme4)
library(geex)
```

# Model 1

\begin{align*}
Y_{ij} &= \beta_0 + X_{ij}\beta + b_i + \epsilon_{ij} \\
\beta_0 &= 1.5 \\
\beta &= (2, -1) \\
b_i &\sim \textrm{N}(0,1) \\
\epsilon_{ij} &\sim \textrm{N}(0,\sigma^2)
\end{align*}

The first covariate ($X_1$) is generated from $Exp(1)$ and is time-invariant while the second covariate $X_2$ is generated from $N(0, 1)$ and is time-variant.

## Data Simulation

```{r Simulate.Data.1}
set.seed(95)
# number of clusters; obs. per cluster; total obs
n = 1000; m = 3; N = n*m
# number of fixed effects; fixed effects covariates
p = 3
# fixed effects
beta = c(1.5, 2, -1)
# random error sd; random errors
sigma = 1
epsilon = rnorm(N, 0, sigma)
# number of random effects
q = 1
Z = matrix(1, N)
if (q > 1) { Z = cbind(Z, X[, 1:(q - 1)]) }
# random effects
b = matrix(rnorm(n*q, 0, 1), n)
# b = rt(n = n, df = 10)
# response Y
sample.data = data.frame(id = rep(1:n, each = m), Y = beta[1] + rep(b, each = m) + epsilon)
if (p > 1) {
  sample.data = sample.data %>%
    mutate(X1 = rep(rexp(n, rate = 1), each = m), Y = Y + beta[2] * X1)
}
if (p > 2) {
  sample.data = sample.data %>% 
    mutate(X2 = rnorm(N, 0, 1), Y = Y + beta[3] * X2)
}
# matrix M used for transforming Y 
M = rbind(matrix(1, 1, m), cbind(matrix(0, m - q, q), diag(m - q)))
# M^{-1}
M.inv = solve(M)
M.inv
head(sample.data, 10) %>% knitr::kable()
```

If the covariate X1 is time invariant, then the following cell should return exactly 3

```{r Time.Invariant.Check.1, message=F}
# check for time invariant
sample.data %>% group_by(id, X1) %>% summarise(n = n()) %>%
  .$n %>% mean()
```

## Simulating Measurement Error

```{r}
sample.data = sample.data %>%
  mutate(cens = rep(rbinom(n = n, size = 1, prob = 0.2), each = m),
         X1.err = X1 + (1 - cens)*rep(rnorm(n = n, mean = 0, sd = 0.5), each = m))
sample.data$cens %>% mean()
```

## Parameter Estimation

```{r Estimate.Parameters.1, cache=T, echo=F}
# use lmer() to fit linear mixed effects model
lme.results = lmer(formula = Y ~ X1 + X2 + (1 | id), data = sample.data) %>%
  summary()
lme.err.results = lmer(formula = Y ~ X1.err + X2 + (1 | id), data = sample.data) %>%
  summary()

theta.lme = c(coef(lme.results)[,1], lme.results$sigma^2)
theta.lme.err = c(coef(lme.err.results)[,1], lme.err.results$sigma^2)

# use lmer estimates as initial theta estimates
theta.init = theta.lme.err
names(theta.init) = c(paste0("beta", 1:p - 1), "sigma2")

# use m_estimate() to solve estimating equations defined above
ee.results = m_estimate(estFUN = eff_score_vec, 
                        data = sample.data, units = "id",
                        root_control = setup_root_control(start = theta.init),
                        outer_args = list(response = "Y", invariant.X = "X1.err", variant.X = "X2", cens = "cens"))
theta.ee = coef(ee.results)

se.theta.lme = sqrt(diag(vcov(lme.results)))
se.theta.lme.err = sqrt(diag(vcov(lme.err.results)))
se.theta.ee = sqrt(diag(vcov(ee.results))[1:p])
```

```{r Present.Results.1, echo=F}
# compare beta estimates
results.df <- matrix(c(beta, sigma^2, theta.ee, theta.lme.err, theta.lme), 4, p + 1, T) %>%
  as.data.frame() %>%
  cbind(c("Truth", "Estimating Equation", "lmer() with error", "lmer() without error"), .)
colnames(results.df) <- c("Method", 
                          paste0("$\\beta_", 1:p, "$"),
                          "$\\sigma^2$")
knitr::kable(results.df, caption = "Parameter Estimates")

se.df <- matrix(c(se.theta.ee, se.theta.lme.err, se.theta.lme), 3, p, T) %>%
  as.data.frame() %>%
  cbind(c("Estimating Equation", "lmer() with error", "lmer() without error"), .)
colnames(se.df) <- c("Method", paste0("$\\beta_", 1:p, "$"))

knitr::kable(se.df, caption = "SE Estimates")
```